/**
 * @file Template generator for Agent files
 */

export interface AgentTemplateOptions {
  tools?: string[];
  providers?: string[];
}

/**
 * Generate a TypeScript file for a new agent
 *
 * @param name - Name of the agent
 * @param options - Template options
 * @returns Generated file content
 */
export function generateAgentTemplate(
  name: string,
  options: AgentTemplateOptions = {},
): string {
  const { tools = [], providers = [] } = options;

  const toolsList = tools.length > 0 ? `['${tools.join("', '")}']` : '[]';
  const providersList =
    providers.length > 0 ? `['${providers.join("', '")}']` : '[]';

  return `/**
 * @file ${name} - Custom agent implementation
 *
 * This agent extends BaseAgent to provide specialized functionality.
 * Automatically generated by JBish-Kit CLI.
 *
 * HOW TO EXTEND THIS AGENT:
 * 1. Define your input and output types (replace 'any' below)
 * 2. Implement the execute() method with your agent logic
 * 3. Add custom initialization in onInitialize() if needed
 * 4. Add custom cleanup in onCleanup() if needed
 * 5. Add helper methods as needed for your logic
 *
 * @example
 * \`\`\`typescript
 * import { ${name} } from '@repo/core/agents/${name}';
 *
 * const agent = new ${name}();
 * const result = await agent.run({ /* your input */ });
 *
 * if (result.success) {
 *   console.log('Result:', result.data);
 *   console.log('Duration:', result.metadata?.duration, 'ms');
 * } else {
 *   console.error('Error:', result.error);
 * }
 * \`\`\`
 */

import { BaseAgent, AgentConfig, AgentResult } from './BaseAgent';

/**
 * Input type for ${name}
 *
 * TODO: Define the structure of data this agent accepts
 */
export interface ${name}Input {
  // Add your input fields here
  // Example:
  // data: string;
  // options?: {
  //   mode: 'fast' | 'thorough';
  // };
}

/**
 * Output type for ${name}
 *
 * TODO: Define the structure of data this agent returns
 */
export interface ${name}Output {
  // Add your output fields here
  // Example:
  // result: string;
  // metadata: {
  //   processingTime: number;
  // };
}

/**
 * ${name} - [Add brief description here]
 *
 * [Add detailed description of what this agent does and how it works]
 *
 * Key Features:
 * - [Feature 1]
 * - [Feature 2]
 * - [Feature 3]
 *
 * Use Cases:
 * - [Use case 1]
 * - [Use case 2]
 */
export class ${name} extends BaseAgent<${name}Input, ${name}Output> {
  /**
   * Create a new ${name} instance
   */
  constructor() {
    super('${name}', {
      description: 'TODO: Add a brief description of what this agent does',
      version: '1.0.0',
      capabilities: [
        // Add agent capabilities here
        // Example: 'data-processing', 'file-analysis', 'web-scraping'
      ],
      tools: ${toolsList},
      providers: ${providersList},
    });
  }

  /**
   * Initialize the agent
   *
   * This hook is called once before the first execution.
   * Override this to set up any resources, connections, or state.
   *
   * @example
   * \`\`\`typescript
   * protected async onInitialize(): Promise<void> {
   *   // Initialize database connection
   *   this.db = await connectToDatabase();
   *   
   *   // Load configuration
   *   this.config = await loadConfig();
   *   
   *   // Set up external API clients
   *   this.apiClient = new APIClient(process.env.API_KEY);
   * }
   * \`\`\`
   */
  protected async onInitialize(): Promise<void> {
    this.log('Initializing ${name}...');
    
    // TODO: Add your initialization logic here
    // Examples:
    // - Connect to databases
    // - Initialize API clients
    // - Load configuration files
    // - Set up external services
    
    this.log('${name} initialized successfully');
  }

  /**
   * Execute the agent's core logic
   *
   * This is where you implement the main functionality of your agent.
   * The method receives typed input and must return typed output.
   *
   * Tips:
   * - Use this.log() to add debug information
   * - Throw errors for exceptional cases (they'll be caught automatically)
   * - Break complex logic into helper methods
   * - Keep this method focused on orchestration
   *
   * @param input - The input data for this agent
   * @returns The processed output
   *
   * @example
   * \`\`\`typescript
   * protected async execute(input: ${name}Input): Promise<${name}Output> {
   *   this.log('Processing input data...');
   *   
   *   // Validate input
   *   this.validateInput(input);
   *   
   *   // Process data
   *   const processedData = await this.processData(input.data);
   *   
   *   // Generate result
   *   const result = this.formatOutput(processedData);
   *   
   *   this.log('Processing complete');
   *   return result;
   * }
   * \`\`\`
   */
  protected async execute(input: ${name}Input): Promise<${name}Output> {
    this.log('Starting ${name} execution...');

    // TODO: Implement your agent logic here
    // This is the main entry point for your agent's functionality
    
    // Example structure:
    // 1. Validate input
    // 2. Perform main processing
    // 3. Generate output
    // 4. Return result

    // Placeholder - replace with actual implementation
    throw new Error('${name}.execute() not implemented yet');

    // Example return (uncomment and modify):
    // return {
    //   result: 'processed data',
    //   metadata: {
    //     processingTime: Date.now()
    //   }
    // };
  }

  /**
   * Clean up agent resources
   *
   * This hook is called when the agent is being shut down.
   * Override this to clean up any resources, connections, or state.
   *
   * @example
   * \`\`\`typescript
   * protected async onCleanup(): Promise<void> {
   *   // Close database connection
   *   await this.db?.close();
   *   
   *   // Clear caches
   *   this.cache?.clear();
   *   
   *   // Shut down external clients
   *   await this.apiClient?.disconnect();
   * }
   * \`\`\`
   */
  protected async onCleanup(): Promise<void> {
    this.log('Cleaning up ${name}...');
    
    // TODO: Add your cleanup logic here
    // Examples:
    // - Close database connections
    // - Clear caches
    // - Shut down external services
    // - Release file handles
    
    this.log('${name} cleanup complete');
  }

  // ============================================================================
  // HELPER METHODS
  // ============================================================================
  // Add your helper methods below this line.
  // Keep them private or protected based on your needs.
  
  /**
   * Example helper method - Validate input data
   *
   * @param input - Input to validate
   * @throws Error if input is invalid
   */
  private validateInput(input: ${name}Input): void {
    // TODO: Add validation logic
    // Example:
    // if (!input.data) {
    //   throw new Error('Input data is required');
    // }
  }

  /**
   * Example helper method - Process data
   *
   * @param data - Data to process
   * @returns Processed data
   */
  private async processData(data: any): Promise<any> {
    // TODO: Add processing logic
    return data;
  }

  /**
   * Example helper method - Format output
   *
   * @param data - Data to format
   * @returns Formatted output
   */
  private formatOutput(data: any): ${name}Output {
    // TODO: Add formatting logic
    return data as ${name}Output;
  }
}

// ============================================================================
// USAGE EXAMPLES
// ============================================================================

/**
 * Example 1: Basic usage
 *
 * \`\`\`typescript
 * const agent = new ${name}();
 * const result = await agent.run({
 *   // your input data
 * });
 *
 * if (result.success) {
 *   console.log('Success!', result.data);
 * } else {
 *   console.error('Failed:', result.error);
 * }
 * \`\`\`
 */

/**
 * Example 2: With error handling
 *
 * \`\`\`typescript
 * const agent = new ${name}();
 *
 * try {
 *   const result = await agent.run(input);
 *   
 *   if (result.success) {
 *     // Handle success
 *     processResult(result.data);
 *   } else {
 *     // Handle failure
 *     logError(result.error);
 *   }
 * } finally {
 *   // Clean up
 *   await agent.cleanup();
 * }
 * \`\`\`
 */

/**
 * Example 3: In an API endpoint
 *
 * \`\`\`typescript
 * export default {
 *   async fetch(request: Request): Promise<Response> {
 *     const input = await request.json();
 *     
 *     const agent = new ${name}();
 *     const result = await agent.run(input);
 *     
 *     return Response.json(result);
 *   }
 * };
 * \`\`\`
 */
`;
}
